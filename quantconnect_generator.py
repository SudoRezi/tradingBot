#!/usr/bin/env python3
"""
QuantConnect Strategy Generator
Converte strategie AI in formato LEAN compatibile con QuantConnect
"""

import os
import json
from datetime import datetime
from typing import Dict, List, Any

class QuantConnectGenerator:
    """Genera strategie QuantConnect dal sistema AI"""
    
    def __init__(self, strategies_path="strategies"):
        self.strategies_path = strategies_path
        os.makedirs(strategies_path, exist_ok=True)
        
    def generate_lean_strategy(self, ai_strategy: Dict, strategy_name: str) -> str:
        """Converte strategia AI in codice LEAN Python"""
        
        # Template base per strategia LEAN
        lean_template = f'''# AUTOGENERATED BY AI TRADING BOT
# Strategy: {strategy_name}
# Generated: {datetime.now().isoformat()}

from AlgorithmImports import *

class {self._sanitize_class_name(strategy_name)}(QCAlgorithm):
    """
    AI Generated Trading Strategy
    Based on: {ai_strategy.get("description", "AI Multi-Model Strategy")}
    """
    
    def Initialize(self):
        """Initialize the algorithm"""
        
        # Set strategy timeframe
        self.SetStartDate({ai_strategy.get("start_year", 2022)}, {ai_strategy.get("start_month", 1)}, {ai_strategy.get("start_day", 1)})
        self.SetEndDate({ai_strategy.get("end_year", 2024)}, {ai_strategy.get("end_month", 12)}, {ai_strategy.get("end_day", 31)})
        self.SetCash({ai_strategy.get("initial_cash", 100000)})
        
        # Add securities
        {self._generate_securities_setup(ai_strategy)}
        
        # Set strategy parameters
        {self._generate_parameters_setup(ai_strategy)}
        
        # Initialize indicators
        {self._generate_indicators_setup(ai_strategy)}
        
        # Set risk management
        {self._generate_risk_management(ai_strategy)}
        
    def OnData(self, data):
        """Main trading logic"""
        
        {self._generate_trading_logic(ai_strategy)}
        
    def OnEndOfDay(self, symbol):
        """End of day processing"""
        
        {self._generate_eod_logic(ai_strategy)}
        
    def OnOrderEvent(self, orderEvent):
        """Handle order events"""
        
        if orderEvent.Status == OrderStatus.Filled:
            self.Debug(f"Order filled: {{orderEvent.Symbol}} {{orderEvent.Direction}} {{orderEvent.FillQuantity}}")
            
    {self._generate_helper_methods(ai_strategy)}
'''
        
        return lean_template
    
    def _sanitize_class_name(self, name: str) -> str:
        """Pulisce il nome per creare una classe valida"""
        import re
        # Rimuove caratteri non alfanumerici e converte in PascalCase
        clean_name = re.sub(r'[^a-zA-Z0-9]', '', name)
        return f"AI{clean_name}Strategy"
    
    def _generate_securities_setup(self, strategy: Dict) -> str:
        """Genera setup dei securities"""
        symbols = strategy.get("symbols", ["SPY", "BTC-USD"])
        securities_code = []
        
        for symbol in symbols:
            if "BTC" in symbol or "ETH" in symbol or "crypto" in symbol.lower():
                # Crypto setup
                securities_code.append(f'        self.AddCrypto("{symbol}", Resolution.{strategy.get("resolution", "Hour")})')
            else:
                # Equity setup
                securities_code.append(f'        self.AddEquity("{symbol}", Resolution.{strategy.get("resolution", "Hour")})')
        
        securities_code.append(f'        # Universe selection based on AI recommendations')
        securities_code.append(f'        self.SetBenchmark("{symbols[0]}")')
        
        return "\n".join(securities_code)
    
    def _generate_parameters_setup(self, strategy: Dict) -> str:
        """Genera setup parametri strategia"""
        params = strategy.get("parameters", {})
        params_code = []
        
        # Parametri di default se non specificati
        default_params = {
            "rsi_period": 14,
            "rsi_overbought": 70,
            "rsi_oversold": 30,
            "ma_fast": 10,
            "ma_slow": 30,
            "risk_per_trade": 0.02,
            "max_positions": 5
        }
        
        # Merge con parametri AI
        all_params = {**default_params, **params}
        
        for param, value in all_params.items():
            params_code.append(f'        self.{param} = {value}')
        
        return "\n".join(params_code)
    
    def _generate_indicators_setup(self, strategy: Dict) -> str:
        """Genera setup indicatori tecnici"""
        indicators = strategy.get("indicators", ["RSI", "SMA", "EMA"])
        indicators_code = []
        
        symbols = strategy.get("symbols", ["SPY"])
        
        for symbol in symbols:
            indicators_code.append(f'        # Indicators for {symbol}')
            
            if "RSI" in indicators:
                indicators_code.append(f'        self.rsi_{symbol.replace("-", "_")} = self.RSI("{symbol}", self.rsi_period)')
            
            if "SMA" in indicators:
                indicators_code.append(f'        self.sma_fast_{symbol.replace("-", "_")} = self.SMA("{symbol}", self.ma_fast)')
                indicators_code.append(f'        self.sma_slow_{symbol.replace("-", "_")} = self.SMA("{symbol}", self.ma_slow)')
            
            if "EMA" in indicators:
                indicators_code.append(f'        self.ema_fast_{symbol.replace("-", "_")} = self.EMA("{symbol}", self.ma_fast)')
                indicators_code.append(f'        self.ema_slow_{symbol.replace("-", "_")} = self.EMA("{symbol}", self.ma_slow)')
            
            if "MACD" in indicators:
                indicators_code.append(f'        self.macd_{symbol.replace("-", "_")} = self.MACD("{symbol}", 12, 26, 9)')
        
        return "\n".join(indicators_code)
    
    def _generate_risk_management(self, strategy: Dict) -> str:
        """Genera codice risk management"""
        risk_code = []
        
        risk_params = strategy.get("risk_management", {})
        
        risk_code.append(f'        # Risk Management Setup')
        risk_code.append(f'        self.SetRiskManagement(MaximumUnrealizedDeviationPercentPerSecurity({risk_params.get("max_unrealized_deviation", 0.05)}))')
        risk_code.append(f'        self.SetRiskManagement(MaximumDrawdownPercentPerSecurity({risk_params.get("max_drawdown", 0.10)}))')
        
        return "\n".join(risk_code)
    
    def _generate_trading_logic(self, strategy: Dict) -> str:
        """Genera logica di trading principale"""
        logic_type = strategy.get("logic_type", "technical_indicators")
        symbols = strategy.get("symbols", ["SPY"])
        
        trading_code = []
        trading_code.append(f'        # AI Generated Trading Logic')
        trading_code.append(f'        for symbol in self.Securities.Keys:')
        trading_code.append(f'            if not data.ContainsKey(symbol) or not data[symbol]:')
        trading_code.append(f'                continue')
        trading_code.append(f'')
        
        if logic_type == "technical_indicators":
            trading_code.extend(self._generate_technical_logic(strategy))
        elif logic_type == "mean_reversion":
            trading_code.extend(self._generate_mean_reversion_logic(strategy))
        elif logic_type == "momentum":
            trading_code.extend(self._generate_momentum_logic(strategy))
        else:
            trading_code.extend(self._generate_hybrid_logic(strategy))
        
        return "\n".join(trading_code)
    
    def _generate_technical_logic(self, strategy: Dict) -> List[str]:
        """Genera logica basata su indicatori tecnici"""
        return [
            '            # Technical Indicators Strategy',
            '            symbol_clean = str(symbol).replace("-", "_")',
            '            ',
            '            # Get indicators',
            '            rsi = getattr(self, f"rsi_{symbol_clean}", None)',
            '            sma_fast = getattr(self, f"sma_fast_{symbol_clean}", None)',
            '            sma_slow = getattr(self, f"sma_slow_{symbol_clean}", None)',
            '            ',
            '            if not (rsi and rsi.IsReady and sma_fast and sma_fast.IsReady):',
            '                continue',
            '            ',
            '            current_price = data[symbol].Close',
            '            holdings = self.Portfolio[symbol].Quantity',
            '            ',
            '            # Buy Signal: RSI oversold + SMA crossover',
            '            if (rsi.Current.Value < self.rsi_oversold and ',
            '                sma_fast.Current.Value > sma_slow.Current.Value and',
            '                holdings <= 0):',
            '                ',
            '                quantity = self.CalculateOrderQuantity(symbol, self.risk_per_trade)',
            '                self.MarketOrder(symbol, quantity)',
            '                self.Debug(f"BUY {symbol}: RSI={rsi.Current.Value:.2f}, Price={current_price}")',
            '            ',
            '            # Sell Signal: RSI overbought + SMA crossover down',
            '            elif (rsi.Current.Value > self.rsi_overbought and',
            '                  sma_fast.Current.Value < sma_slow.Current.Value and',
            '                  holdings > 0):',
            '                ',
            '                self.Liquidate(symbol)',
            '                self.Debug(f"SELL {symbol}: RSI={rsi.Current.Value:.2f}, Price={current_price}")'
        ]
    
    def _generate_mean_reversion_logic(self, strategy: Dict) -> List[str]:
        """Genera logica mean reversion"""
        return [
            '            # Mean Reversion Strategy',
            '            symbol_clean = str(symbol).replace("-", "_")',
            '            sma = getattr(self, f"sma_slow_{symbol_clean}", None)',
            '            ',
            '            if not (sma and sma.IsReady):',
            '                continue',
            '            ',
            '            current_price = data[symbol].Close',
            '            mean_price = sma.Current.Value',
            '            deviation = (current_price - mean_price) / mean_price',
            '            holdings = self.Portfolio[symbol].Quantity',
            '            ',
            '            # Buy when price is significantly below mean',
            '            if deviation < -0.05 and holdings <= 0:',
            '                quantity = self.CalculateOrderQuantity(symbol, self.risk_per_trade)',
            '                self.MarketOrder(symbol, quantity)',
            '                self.Debug(f"BUY {symbol}: Price below mean by {deviation:.2%}")',
            '            ',
            '            # Sell when price returns to mean or above',
            '            elif deviation > 0.02 and holdings > 0:',
            '                self.Liquidate(symbol)',
            '                self.Debug(f"SELL {symbol}: Price at mean, deviation {deviation:.2%}")'
        ]
    
    def _generate_momentum_logic(self, strategy: Dict) -> List[str]:
        """Genera logica momentum"""
        return [
            '            # Momentum Strategy',
            '            symbol_clean = str(symbol).replace("-", "_")',
            '            ema_fast = getattr(self, f"ema_fast_{symbol_clean}", None)',
            '            ema_slow = getattr(self, f"ema_slow_{symbol_clean}", None)',
            '            ',
            '            if not (ema_fast and ema_fast.IsReady and ema_slow and ema_slow.IsReady):',
            '                continue',
            '            ',
            '            current_price = data[symbol].Close',
            '            holdings = self.Portfolio[symbol].Quantity',
            '            ',
            '            # Strong momentum up',
            '            momentum_strength = (ema_fast.Current.Value - ema_slow.Current.Value) / ema_slow.Current.Value',
            '            ',
            '            if momentum_strength > 0.02 and holdings <= 0:',
            '                quantity = self.CalculateOrderQuantity(symbol, self.risk_per_trade)',
            '                self.MarketOrder(symbol, quantity)',
            '                self.Debug(f"BUY {symbol}: Strong momentum {momentum_strength:.2%}")',
            '            ',
            '            elif momentum_strength < -0.01 and holdings > 0:',
            '                self.Liquidate(symbol)',
            '                self.Debug(f"SELL {symbol}: Momentum weakening {momentum_strength:.2%}")'
        ]
    
    def _generate_hybrid_logic(self, strategy: Dict) -> List[str]:
        """Genera logica ibrida AI"""
        return [
            '            # Hybrid AI Strategy',
            '            symbol_clean = str(symbol).replace("-", "_")',
            '            ',
            '            # Get all available indicators',
            '            rsi = getattr(self, f"rsi_{symbol_clean}", None)',
            '            sma_fast = getattr(self, f"sma_fast_{symbol_clean}", None)',
            '            sma_slow = getattr(self, f"sma_slow_{symbol_clean}", None)',
            '            ',
            '            if not all([rsi and rsi.IsReady, sma_fast and sma_fast.IsReady]):',
            '                continue',
            '            ',
            '            # AI Scoring System',
            '            ai_score = self.CalculateAIScore(symbol, data[symbol], rsi, sma_fast, sma_slow)',
            '            holdings = self.Portfolio[symbol].Quantity',
            '            ',
            '            if ai_score > 0.7 and holdings <= 0:',
            '                quantity = self.CalculateOrderQuantity(symbol, self.risk_per_trade)',
            '                self.MarketOrder(symbol, quantity)',
            '                self.Debug(f"BUY {symbol}: AI Score {ai_score:.2f}")',
            '            ',
            '            elif ai_score < 0.3 and holdings > 0:',
            '                self.Liquidate(symbol)',
            '                self.Debug(f"SELL {symbol}: AI Score {ai_score:.2f}")'
        ]
    
    def _generate_eod_logic(self, strategy: Dict) -> str:
        """Genera logica end-of-day"""
        return '''        # End of day processing
        self.Debug(f"End of day portfolio value: {self.Portfolio.TotalPortfolioValue}")
        
        # Log performance metrics
        if hasattr(self, 'previous_portfolio_value'):
            daily_return = (self.Portfolio.TotalPortfolioValue - self.previous_portfolio_value) / self.previous_portfolio_value
            self.Debug(f"Daily return: {daily_return:.2%}")
        
        self.previous_portfolio_value = self.Portfolio.TotalPortfolioValue'''
    
    def _generate_helper_methods(self, strategy: Dict) -> str:
        """Genera metodi helper"""
        return '''    
    def CalculateAIScore(self, symbol, data, rsi, sma_fast, sma_slow):
        """Calculate AI composite score for trading decision"""
        
        score = 0.5  # Neutral starting point
        
        # RSI component (30% weight)
        if rsi and rsi.IsReady:
            if rsi.Current.Value < 30:
                score += 0.15  # Oversold is bullish
            elif rsi.Current.Value > 70:
                score -= 0.15  # Overbought is bearish
        
        # Moving Average component (40% weight)
        if sma_fast and sma_slow and sma_fast.IsReady and sma_slow.IsReady:
            if sma_fast.Current.Value > sma_slow.Current.Value:
                score += 0.2  # Fast above slow is bullish
            else:
                score -= 0.2  # Fast below slow is bearish
        
        # Price momentum component (30% weight)
        if len(self.Securities[symbol].Price) > 1:
            price_change = (data.Close - self.Securities[symbol].Price) / self.Securities[symbol].Price
            score += price_change * 5  # Amplify price momentum
        
        # Clamp score between 0 and 1
        return max(0, min(1, score))
    
    def OnSecuritiesChanged(self, changes):
        """Handle universe changes"""
        for added in changes.AddedSecurities:
            self.Debug(f"Added security: {added.Symbol}")
        
        for removed in changes.RemovedSecurities:
            self.Debug(f"Removed security: {removed.Symbol}")'''
    
    def save_strategy(self, strategy_code: str, strategy_name: str) -> str:
        """Salva strategia su file"""
        
        # Pulisci nome file
        filename = f"{strategy_name.replace(' ', '_').replace('-', '_')}.py"
        filepath = os.path.join(self.strategies_path, filename)
        
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(strategy_code)
        
        return filepath
    
    def generate_config_file(self, strategy_name: str, config: Dict) -> str:
        """Genera file di configurazione per LEAN"""
        
        config_data = {
            "algorithm-type-name": self._sanitize_class_name(strategy_name),
            "algorithm-language": "Python",
            "algorithm-location": f"strategies/{strategy_name.replace(' ', '_').replace('-', '_')}.py",
            "data-folder": "./data",
            "debugging": True,
            "debugging-method": "LocalCmdline",
            "log-handler": "ConsoleLogHandler",
            "messaging-handler": "RestMessagingHandler",
            "queue-handler": "LocalQueueHandler",
            "api-handler": "LocalApiHandler",
            "map-file-provider": "LocalDiskMapFileProvider",
            "factor-file-provider": "LocalDiskFactorFileProvider",
            "data-provider": "DefaultDataProvider",
            "alpha-handler": "DefaultAlphaHandler",
            "object-store": "LocalObjectStore",
            "data-channel-provider": "DefaultDataChannelProvider",
            **config
        }
        
        config_filepath = os.path.join(self.strategies_path, f"{strategy_name}_config.json")
        
        with open(config_filepath, 'w', encoding='utf-8') as f:
            json.dump(config_data, f, indent=2)
        
        return config_filepath

def test_generator():
    """Test del generatore"""
    
    # Strategia AI di esempio
    ai_strategy = {
        "description": "AI Multi-Indicator Strategy with RSI and Moving Averages",
        "symbols": ["SPY", "QQQ", "BTC-USD"],
        "logic_type": "technical_indicators",
        "parameters": {
            "rsi_period": 14,
            "rsi_overbought": 75,
            "rsi_oversold": 25,
            "ma_fast": 12,
            "ma_slow": 26,
            "risk_per_trade": 0.03
        },
        "indicators": ["RSI", "SMA", "EMA"],
        "risk_management": {
            "max_unrealized_deviation": 0.08,
            "max_drawdown": 0.15
        },
        "start_year": 2023,
        "end_year": 2024,
        "initial_cash": 100000
    }
    
    generator = QuantConnectGenerator()
    
    # Genera strategia
    strategy_code = generator.generate_lean_strategy(ai_strategy, "AI_Multi_Indicator_Strategy")
    
    # Salva strategia
    filepath = generator.save_strategy(strategy_code, "AI_Multi_Indicator_Strategy")
    
    # Genera config
    config_filepath = generator.generate_config_file("AI_Multi_Indicator_Strategy", {})
    
    print(f"Strategy generated: {filepath}")
    print(f"Config generated: {config_filepath}")
    
    return filepath, config_filepath

if __name__ == "__main__":
    test_generator()